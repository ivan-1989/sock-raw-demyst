# vim: set textwidth=90:

SOCK_RAW демеcтификация
by ithilgore - ithilgore.ryu.L@gmail.com
sock-raw.org / sock-raw.homeunix.org
May 2008


0x0. Оглавление
0x1. Введение
0x2. Создание
0x3. IP_HDRINCL
0x4. raw input
0x5. raw output
0x6. Описание
0x7. Заключение
0x8. Ссылки

0x1. Введение
=================

Цель данного исследования - объяснить, довольно часто не понимаемую  природу raw
sockets(сырых сокетов).  Движущей силой для написания этого текста было любопытство 
автора - в изучении всех тонкостей этого мощного типа сокетов, также изветного как 
SOCK_RAW.  То о чем здесь будет вестись рассказ - это не очередное руководство по 
созданию своего типа пакетов. Данная тема была много раз обговорена и в сети можно легко
найти несколько ссылок об этом. Здесь будет описано - что делает  RAW_SOCKET 
"за сценой". Поэтой причине мы углубимся в реализацию сетевого стека. Мы предполагаем,
что читатель уже имеет опыт по работе с сокетами и сможет читать исходный код ядра ОС,
поскольку реализация сырых сокетов,в данный момент, отличается от одной операционной 
системы к другой. Мы обсудим реализацию от FreeBSD 7.0 и Linux 2.6. В большинстве 
случаев примеры для  FreeBSD так же применимы к  OpenBSD, NetBSD и даже  к MAC OS X.

0x2. Cоздание
=============

Сначала - начало(обо всем по порядку). Создание. Как создается сырой сокет? Какие 
основные сложности? Сырой сокет создается системным вызовом socket(2)  и определяет тип
сокета как SOCK_RAW, как здесь:
	int fd = socket(AF_INET, SOCK_RAW, XXX);
где, XXX - это *int protocol*, и как мы и обсудим далее - это главный источник непонимая 
и проблем, выходящиe из самого факта что здесь могут быть применены различные 
комбинации.  Валидные значения: IPPROTO_ICMP, IPPOROTO_IGMP, IPPROTO_TCP, 0 (здесь 
осторожно - см. ниже), IPPROTO_UDP и тд. Различныe комбинации - различное поведение.
И это поведение - критично при взаимодействии ядра с приложением создавшим  сырой сокет.

Прежде чем вдаваться в подробности комбинаций для каждой ОС, давайте для начала 
посмотрим на актуальное определение значения - *protocol*. Для работы всех протоколов 
одновременно, был использован  общий подход к дизайну.  Основываясь на этом 
похожие протоколы сгруппированы в домены. Домен как правило определяется - Protocol 
Family или Address Family ( последнее более современная практика ) и постоянными числами
используемыми для различия между ними. Наиболее распространенные из них:

PF_INET / AF_INET 			--> Internet protocols (TCP, UDP etc)
PF_LOCAL, PF_UNIX / AF_LOCAL, AF_UNIX	--> Unix local IPC protocol
PF_ROUTE / AF_ROUTE 			--> routing tables 

Linux определяет эти константы в /usr/src/linux-2.6.*/include/linux/socket.h

/* Supported address families. */
#define AF_UNSPEC	0
#define AF_UNIX		1	/* Unix domain sockets 		*/
#define AF_LOCAL	1	/* POSIX name for AF_UNIX	*/
#define AF_INET		2	/* Internet IP Protocol 	*/
  	/* ... */

/* Protocol families, same as address families. */
#define PF_UNSPEC	AF_UNSPEC
#define PF_UNIX		AF_UNIX
#define PF_LOCAL	AF_LOCAL
#define PF_INET		AF_INET
 	/* ... */

FreeBSD отпределяет эти значения ( почти так же ) в /usr/src/sys/sys/socket.h

Как вы уже могли предположить, мы будем рассматривать AF_INET. AF_INET делится на типы 
протоколов, которые  могут состоять из более чем одного протокола. 

Linux определяет типы протоколов AF_INET в /usr/src/linux-2.6.*/include/linux/net.h

enum sock_type {
	SOCK_STREAM	= 1,
	SOCK_DGRAM	= 2,
	SOCK_RAW	= 3,
	SOCK_RDM	= 4,
	SOCK_SEQPACKET	= 5,
	SOCK_DCCP	= 6,
	SOCK_PACKET	= 10,
};

FreeBSD /usr/src/sys/sys/socket.h

/*
 * Types
 */
#define	SOCK_STREAM	1		/* stream socket */
#define	SOCK_DGRAM	2		/* datagram socket */
#define	SOCK_RAW	3		/* raw-protocol interface */
#if __BSD_VISIBLE
#define	SOCK_RDM	4		/* reliably-delivered message */
#endif
#define	SOCK_SEQPACKET	5		/* sequenced packet stream */

Если вы уже имеетe опыт программирования сокетов, тогда возможно вы узнали кое-что
из представленного выше. Один из них является вторым аргументом в системном вызове 
socket(AF_INET, ..., ...). Третий аргумент это IPPROTO_XXX значение которое определяет 
протокол выше IP. Важно понять смысл этого значения. Это значение\номер которое IP 
уровень будет писать в поле protocol_type заголовка для определения верхнеуровнего 
заголовка. 
Это поле "Protocol" как вы видите в IP заголовокe ниже (RFC 791).

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Это одно из наиболее важных полей, поскольку только его будет использовать IP уровень на
принимаемой стороне для определения какого типа датаграмма вышестоящего уровня 
доставлена( например TCP или UDP ).

Linux определяет эти протоколы в /usr/src/linux-2.6.*/include/linux/in.h

/* Standard well-defined IP protocols.  */
enum {
	IPPROTO_IP = 0,			/* Dummy protocol for TCP		*/
	IPPROTO_ICMP = 1,		/* Internet Control Message Protocol	*/
	IPPROTO_IGMP = 2,		/* Internet Group Management Protocol	*/
	IPPROTO_IPIP = 4,		/* IPIP tunnels (older KA9Q tunnels use 94) */
	IPPROTO_TCP = 6,		/* Transmission Control Protocol	*/
	IPPROTO_EGP = 8,		/* Exterior Gateway Protocol		*/
	IPPROTO_PUP = 12,		/* PUP protocol				*/
	IPPROTO_UDP = 17,		/* User Datagram Protocol		*/
	IPPROTO_IDP = 22,		/* XNS IDP protocol			*/
	IPPROTO_DCCP = 33,		/* Datagram Congestion Control Protocol */
	IPPROTO_RSVP = 46,		/* RSVP protocol			*/
	IPPROTO_GRE = 47,		/* Cisco GRE tunnels (rfc 1701,1702)	*/
	IPPROTO_IPV6 = 41,		/* IPv6-in-IPv4 tunnelling		*/
	IPPROTO_ESP = 50,       	/* Encapsulation Security Payload protocol */
	IPPROTO_AH = 51,             	/* Authentication Header protocol       */
	IPPROTO_BEETPH = 94,	       	/* IP option pseudo header for BEET */
	IPPROTO_PIM    = 103,		/* Protocol Independent Multicast	*/
	IPPROTO_COMP   = 108,           /* Compression Header protocol */
	IPPROTO_SCTP   = 132,		/* Stream Control Transport Protocol	*/
	IPPROTO_UDPLITE = 136,		/* UDP-Lite (RFC 3828)			*/
	IPPROTO_RAW	 = 255,		/* Raw IP packets			*/
	IPPROTO_MAX
};

FreeBSD /usr/src/sys/netinet/in.h

Пример для IPPROTO_RAW:

#if __POSIX_VISIBLE >= 200112
#define	IPPROTO_RAW		255		/* raw IP packet */
#define	INET_ADDRSTRLEN		16
#endif

С таким количеством комбинаций лучше обсуждать вещи последовательно. Итак  начнем 
с наиболее используемого значения 0 в поле протокол. Вы когда-нибудь задумывались 
как системный вызов syscall(2) магическим образом определяет какой протокол 
использовать если он был вызван как socket(..., ..., 0)?
Например когда приложение вызывает его так:

	socket(AF_INET, SOCK_STREAM, 0);

Как ядро находит какой протокол ассоциировать с сокетом? Факт то, что ядро не делает 
никаких предположений - ядро не играет в кости c userspace ( цитируя сумашедшего 
медика и великую голову http://www.quotedb.com/quotes/878 в слегка измененном контексте)
- в большинстве случаев( см. encryption & entropy для противоположной парадигмы)
На FreeBSD все что делается - это ассоциируется первый  протокол найденный в списке 
слинкованных доменов, с помощью функции pffindproto(dom, type).

Давайте будем более предметными и рассмотрим немого PoC (proof of concept) кода:

Сокет создается с помощью функции ядра socreate()  которая определяется так:
(исходный код из FreeBSD 7.0 /usr/src/sys/kern/uipc_socket.c)


/*
 * socreate returns a socket with a ref count of 1.  The socket should be
 * closed with soclose().
 */
int
socreate(int dom, struct socket **aso, int type, int proto,
    struct ucred *cred, struct thread *td)
{
	struct protosw *prp;
	struct socket *so;
	int error;

	if (proto)
		prp = pffindproto(dom, proto, type);
	else
		prp = pffindtype(dom, type); 

	/* .... */
}


Секрет лжи в двух функциях pffindproto() и pffindtype(). Если  proto == 0 тогда 
вызывается pffindtype, которая менее строгая чем pffindproto(). Как мы можем выдеть из
исходного кода, pffindtype() не делает проверку proto совсем и просто возвращает 
*первую* структуру protosw которую находит, выводя это просто из pr_type( protocol 
type: SOCK_STREAM , SOCK_DGRAM, SOCK_RAW etc ) и family/domain ( AF_INET, AF_LOCAL 
и т.д. )
Каждая структура protosw (protoco switch) это соотношение SOCK_XXX type и IPPROTO_XXX
protocol.  Все protosw структуры внутри таблицы  inetsw[], на которую указывает 
inetdomain в глобальном списке доменов.
Графическое представление может немного прояснить ситуацию:

domains:
---------
|	|			(domain linked list)
---------
    |
    |------------> 	isodomain:             	inetdomain:
			---------      		--------- 
		-------	|	| -----> -------|	| ------->    .....
		|	---------      	 |	---------
		|	               	 |	
		|		       	 |		
		|---> isosw[]:         	 |---> inetsw[]:
			---------      		---------
			|	|      		|  IP	|
			---------      		---------
			|	|      		|  UDP	|
			---------      		---------
			|	|      		|  TCP	|
			---------      		---------
			|	|      		|IP(raw)| (default entry)
			---------      		---------
			|	|      		| ICMP	|
			---------      		---------
				       		| IGMP	|	
                                                ---------
						|  ...  |
						---------
						|  ...  |
						---------
				       		|IP(raw)| (wildcard entry)
                                                ---------
Замечание: Размещение IP(raw) в 4ом индексе(inetsw[3]) упомянуто по историческим 
причинам и новые реализации FreeBSD стэка отличаются в этом отношении. В частности,
если объявлена  поддержка SCTP ядром, тогда IP(raw), ICMP и оставшиеся переезжают на
3 позиции вверх таблицы,  inetsw[] фактически становится inetsw[6], inetsw[7] и т.д
Конечно это не имеет никаких определенных различий в ядре поскольку inetsw[] никогда
не доступен по индексу, только по имени. По всему тексту мы будем использовать 
соглашение ссылающееся на значение по умолчанию (inetsw[3]) как default_RAW и wildcard
RAW значение ( последнее значение inetsw[] и устаревшее inetsw[6]) как wildcard_RAW для
ясности.

Запись raw wildcard ( у которого для .pr_protocol не установлено значение и таким 
образом имеющее значение 0 ) определяется как последний член inetsw[] массива в
/usr/src/sys/netinet/in_proto.h:

/* raw wildcard */
{
	.pr_type =		SOCK_RAW,
	.pr_domain =		&inetdomain,
	.pr_flags =		PR_ATOMIC|PR_ADDR,
	.pr_input =		rip_input,
	.pr_ctloutput =		rip_ctloutput,
	.pr_init =		rip_init,
	.pr_usrreqs =		&rip_usrreqs
},
};  /* end of inetsw[] */

Вернемся к поиску, который происходит так:
	pffindtype: 	1. найти соответсвующий домен через значение *family*
			2. вернуть первое вхождение соответсвующей protosw таблицы
			которое совпадает сo значением *type*
	pffindproto: 	1. найти соответсвующий домен через значение *family*
			2. вернуть первое совпадение пары *type* - *protocol*
			3. если пары не найдено и тип SOCK_RAW тогда вернуть значение
			по умолчанию raw IP - default_RAW ( см. ниже)

Обе функции возвращают вхождение inetsw[] ( указатель на соответcвующее смещение в
массиве )

/usr/src/sys/kernel/uipc_domain.c:

struct protosw *
pffindtype(int family, int type)
{
	struct domain *dp;
	struct protosw *pr;

	for (dp = domains; dp; dp = dp->dom_next)
		if (dp->dom_family == family)
			goto found;
	return (0);
found:
	for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++)
		if (pr->pr_type && pr->pr_type == type)
			return (pr);
	return (0);
}

struct protosw *
pffindproto(int family, int protocol, int type)
{
	struct domain *dp;
	struct protosw *pr;
	struct protosw *maybe = 0;

	if (family == 0)
		return (0);
	for (dp = domains; dp; dp = dp->dom_next)
		if (dp->dom_family == family)
			goto found;
	return (0);
found:
	for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++) {
		if ((pr->pr_protocol == protocol) && (pr->pr_type == type))
			return (pr);

		if (type == SOCK_RAW && pr->pr_type == SOCK_RAW &&
		    pr->pr_protocol == 0 && maybe == (struct protosw *)0)
			maybe = pr;
	}
	return (maybe);
}

Исследуя представленный выше код, мы замечаем другое важное значение SOCK_RAW.
В основном , что делают последние несколько строк pffindproto() - это используют
SOCK_RAW как резервный протокол поумолчанию. Это означает, что если пользовательское 
приложение вызывает socket(2) вот так:
	
	socket(AF_INET, SOCK_RAW, 30);

где значение protocol - 30, не оговорено в ядре, но вместо ошибки, используется
wildcard_RAW. Потому, что только структура protosw в массиве inetsw[] содержит 
.pr_protocol - 0 и pr_type - SOCK_RAW.
Тоже самое происходит при вызове:

	socket(AF_INET, SOCK_RAW, IPPROTO_TCP);

Тип SOCK_RAW и IPPROTO_TCP не совпадают, поскольку SOCK_RAW имеет записи только для
ICMP, IGMP и raw IP. Однако этот вызов прекрасно работает, поскольку ядро вернет
wildcard запись SOCK_RAW.

Это работает для FreeBSD. Насколько это касается Linux, вы можете уже заметить из 
обрывка кода выше (in.h), значение *0* уже определено как другой тип протокола для TCP.
Эта имеет достаточно сильное значение в портировании приложений между *BSD и Linux. 
Для примера, для *BSD это верно:

	socket(AF_INET, SOCK_RAW, 0);

Обратите внимание, что при вводе значения 0 будет возвращенa запись default_RAW, а не
wildcard запись, поскольку pffindtype() вернет первую protosw структуру с типом 
SOCK_RAW внутри  таблицы inetsw[], а первая запись это default_RAW.

На Linux выполучите ошибку EPROTONOSUPPORT. Рассмотрим ниже код ядра ,что-бы понять
почему это произойдет.

/usr/src/linux-2.6.*/net/ipv4/af_inet.c:


/* Upon startup we insert all the elements in inetsw_array[] into
 * the linked list inetsw.
 */
static struct inet_protosw inetsw_array[] =
{
	{
		.type =       SOCK_STREAM,
		.protocol =   IPPROTO_TCP,
		.prot =       &tcp_prot,
		.ops =        &inet_stream_ops,
		.capability = -1,
		.no_check =   0,
		.flags =      INET_PROTOSW_PERMANENT |
			      INET_PROTOSW_ICSK,
	},

	{
		.type =       SOCK_DGRAM,
		.protocol =   IPPROTO_UDP,
		.prot =       &udp_prot,
		.ops =        &inet_dgram_ops,
		.capability = -1,
		.no_check =   UDP_CSUM_DEFAULT,
		.flags =      INET_PROTOSW_PERMANENT,
       },


       {
	       .type =       SOCK_RAW,
	       .protocol =   IPPROTO_IP,	/* wild card */
	       .prot =       &raw_prot,
	       .ops =        &inet_sockraw_ops,
	       .capability = CAP_NET_RAW,
	       .no_check =   UDP_CSUM_DEFAULT,
	       .flags =      INET_PROTOSW_REUSE,
       }
};


static int inet_create(struct net *net, struct socket *sock, int protocol)
{

	/* ... */

/* Look for the requested type/protocol pair. */
	answer = NULL;
lookup_protocol:
	err = -ESOCKTNOSUPPORT;
	rcu_read_lock();
	list_for_each_rcu(p, &inetsw[sock->type]) {
		answer = list_entry(p, struct inet_protosw, list);

		/* Check the non-wild match. */
		if (protocol == answer->protocol) {
			if (protocol != IPPROTO_IP)
				break;
		} else {
			/* Check for the two wild cases. */
			if (IPPROTO_IP == protocol) {
				protocol = answer->protocol;
				break;
			}
			if (IPPROTO_IP == answer->protocol)
				break;
		}
		err = -EPROTONOSUPPORT;
		answer = NULL;
	}

	/* ... */

}


Из представленного выше мы помним, что IPPROTO_IP = 0.
Код представленный выше может быть разбит на:

1) socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	protocol = 6
	answer = inet_protosw[0]
	protocol = answer->protocol  : first "if" TRUE
	OK

2) socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	protocol = 17 
	answer = inet_protosw[1]
	protocol = answer->protocol : first "if" TRUE
	OK

3) socket(AF_INET, SOCK_STREAM, 0);
	protocol = 0
	answer = inet_protosw[0]
	if (protocol == answer->protocol) : FALSE
	check else : 
			/* Check for the two wild cases. */
			if (IPPROTO_IP == protocol) {
				protocol = answer->protocol;
				break;
			}
			: TRUE
	обратите внимение , что значение protocol замещено реальным значением
	IPPROTO_TCP в строке:
		protocol = answer->protocol;
	OK

4) socket(AF_INET, SOCK_DGRAM, 0);
	protocol = 0
	answer = inet_protosw[1]
	if (protocol == answer->protocol) : FALSE
	check else : 
			/* Check for the two wild cases. */
			if (IPPROTO_IP == protocol) {
				protocol = answer->protocol;
				break;
			}
			: TRUE
	обратите внимение , что значение protocol замещено реальным значением
	IPPROTO_UDP в строке:
		protocol = answer->protocol;
	OK

5) socket(AF_INET, SOCK_RAW, 0);
	protocol = 0
	answer = inet_protosw[2]
	protocol == IPPROTO_IP so : if (protocol != IPPROTO_IP)  is FALSE
	not OK -> EPROTONOSUPPORT

6) socket(AF_INET, SOCK_STREAM, 9); (где 9 может быть любым протоколом, за исключением
				  IPPROTO_TCP)
   	protocol = 9
	answer = inet_protosw[0]
	if (protocol == answer->protocol) : FALSE
	check else : 
			/* Check for the two wild cases. */
			if (IPPROTO_IP == protocol) {
				protocol = answer->protocol;
				break;
			}
			if (IPPROTO_IP == answer->protocol)
				break;

	both are a FALSE
	not OK -> EPROTONOSUPPORT

7) socket(AF_INET, SOCK_DGRAM, 9); (где 9 может быть любым протоколом, за исключением
				   IPPROTO_UDP)
	same as above
	not OK -> EPROTONOSUPPORT

8) socket(AF_INET, SOCK_RAW, 9); (где 9 может быть *любым* протоколом, за исключением 0)
	protocol = 9
	answer = inet_protosw[2]
	if (protocol == answer->protocol) : FALSE
	check else : 
			/* Check for the two wild cases. */
			if (IPPROTO_IP == protocol) {
				protocol = answer->protocol;
				break;
			} 
			: FALSE

			if (IPPROTO_IP == answer->protocol)
				break;
			: TRUE
	OK

Вариант 8 показывает как Linux использует SOCK_RAW для резервного протокола, так же мы
видели как его использует FreeBSD.

Это не единственные различия между двумя системами. И мы будем больше разговаривать об 
этом далее.



0x3. IP_HDRINCL
===============

Одним из наиболее серьезных решений при написании низкоуровневых сетевых программ с
сырыми сокетами - если приложение будет создавать вместе с заголовком транспортного 
уровня также IP заголовок. Было бы не плохо для сначала сделать небольшое историческое 
отступление, поскольку много чего изменилось с прошлых времен. В настоящее время,
очевидным cпособом сказать IP уровню не подготавливать свои заголовки - это сделать
системный вызов setsockopt(2) с установленной опцией  IP_HDRINCL (Header Included).
Однако эта опция не всегда присутствует. В релизах до Net/3 не было опции IP_HDRINCL
и единственным способом не дать ядру создавать свои собственные заголовки - было
использование специального патча для ядра и установка protocol как IPPROTO_RAW 
( inetsw[3] -- wildcard entry ). Эти патчи сначала были сделаны в 4.3 BSD и Net/1
для поддержки Traceroute, которой нужно было создавать IP датаграмму полностью
самостоятельно, это связано с тем что утилита использует в работе поле TTL. 
Интересно то, что с момента появления IP_HDRINCL, Linux и FreeBSD выбрали различные пути
продолжения "традиции". На Linux, когда protocol установлен как IPPROTO_RAW, ядро по 
умолчанию устанавливает опцию IP_HDRINCL и следовательно не готовит собственный IP 
заголовок. Кусок кода ниже, доказывает это.

/usr/src/linux-2.6.*/net/ipv4/af_inet.c

static int inet_create(struct net *net, struct socket *sock, int protocol)
{	
	/* ... */
	if (SOCK_RAW == sock->type) {
		inet->num = protocol;
		if (IPPROTO_RAW == protocol)
			inet->hdrincl = 1;      /* set IP_HDRINCL */
	}
	/* ... */
}

Однако на FreeBSD, ядро никогда по умолчанию не устанавливает IP_HDRINCL, даже если 
используется IPPROTO_RAW. Это значит, что приложение явно устанавливает опцию каждый раз
когда хочет самостоятельно создать  IP заголовок. Ниже мы увидим, когда углубимся в 
детали ввода/вывода сырых сокетов, что некоторые поля IP заголовка  всегда устанавливаются
ядром.

Подведем итог, что-бы создать портируемое приложение которому необходимо создавать свой 
собственный IP заголовок, лучше всегда устанавливать IP_HDRINCL, поскольку это будет
работать как для Linux так и для *BSD.
 


0x4. raw input
==============

После того как мы решили использовать сырые сокеты в нашем приложении, мы заранее знаем
какие датаграммы мы ожидаем получать. Подход к реализации здесь, совершенно разный у Linux
и у FreeBSD и заслуживает нашего внимания отдельно.


a. Linux
********

Linux выбрал менее ресурсосберегающий подход. После обработки новой входящей IP датаграммы
IP уровнем, вызывается  функция ядра ip_local_deliver_finish(), которая отвечает за вызов
зарегистрированного обработчика траспортного протокола, исследуя поле protocol заголовка
IP. Однако до того как  доставить датаграмму обработчику, каждый раз проверяется, не было
ли приложением создано raw сокета с *таким же* номером протокола. Если есть одно или более
таких приложений, создается копия датаграммы и также доставляется им.


/usr/src/linux-2.6.*/net/ipv4/ip_input.c

static int ip_local_deliver_finish(struct sk_buff *skb)
{
	__skb_pull(skb, ip_hdrlen(skb));

	/* Point into the IP datagram, just past the header. */
	skb_reset_transport_header(skb);

	rcu_read_lock();
	{
		/* Note: See raw.c and net/raw.h, RAWV4_HTABLE_SIZE==MAX_INET_PROTOS */
		int protocol = ip_hdr(skb)->protocol;
		int hash;
		struct sock *raw_sk;
		struct net_protocol *ipprot;

	resubmit:
		hash = protocol & (MAX_INET_PROTOS - 1);
		raw_sk = sk_head(&raw_v4_htable[hash]);

		/* If there maybe a raw socket we must check - if not we
		 * don't care less
		 */
		if (raw_sk && !raw_v4_input(skb, ip_hdr(skb), hash))
			raw_sk = NULL;

	/* ... */
	/* transport protocol handler calling */
	/* ... */

}

Вопрос который здесь возникает - разве не вся датаграмма передается raw сокету? Только
данные IP или вся IP датаграмма(вместе с IP заголовком). Рассмотрев внимательнее код
представленный выше, мы можем вывести, что передается вся IP датаграмма. Давайте посмотрим
почему:

Во первых мы имеем:

__skb_pull(skb, ip_hdrlen(skb));

Что здесь делается по факту - сдвигается указатель sk_buff на указатель ниже IP
заголовка( не смотря на то, что это звучит как разногласие с тем, что мы вывели выше,
подождите с возникающими возражениями до того как вы дочитаете всю часть полностью).  Это
добавляет размер ip_hdrlen(skb) к skb->data. Это значит, что skb_data теперь указывает на
IP payload - и поскольку пакет направляется вверх по сетевому стеку, начало IP payload это
на самом деле начало транспортного заголовка ( скорее всего TCP )

__skb_pull is defined in:
/usr/src/linux-2.6.*/include/linux/skbuff.h

static inline unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
	skb->len -= len;
	BUG_ON(skb->len < skb->data_len);
	return skb->data += len;
}

После  __skb_pull мы получаем другую  skb-relevant функцию  которая вызывается:

skb_reset_transport_header(skb);

которая обновляет часть структуры skb skb->transport_header  в указатель на новое место
skb->data указывающий до - угадайте что - транспортного заголовка.

skb_reset_transport_header(skb) объявляется в:
/usr/src/linux-2.6.*/include/linux/skbuff.h

static inline void skb_reset_transport_header(struct sk_buff *skb)
{
	skb->transport_header = skb->data;
}

Наша  sk_buff структура будет сейчас выглядеть так:

sk_buff {			    buffer
				-------------- 	
.skb_data                       |	     |
	|                       --------------
        |                       | IP header  | <----
        |                       --------------     |
        -----------------> ->	| IP payload |     |
	                   |    |	     |     |
.transport_header ---------|    |	     |     |
	                        --------------	   |	
.network_header ------------------------------------

}

Чтож в этой части мы видим , что  *вся* IP датаграмма ( вместе с IP заголовком )
отправляется пользовательскому процессу который создал raw сокет ?
Введите raw_v4_input(). 

По имени можно предположить , что это главный обработчик raw сокетов и он вызывается в
ip_local_deliver_finish():

	if (raw_sk && !raw_v4_input(skb, ip_hdr(skb), hash))

Обратите внимание на второй аргумент ip_hdr(skb) в  raw_v4_input. ip_hdr  объявляется в 
/usr/src/linux-2.6.*/include/linux/ip.h:

static inline struct iphdr *ip_hdr(const struct sk_buff *skb)
{
	return (struct iphdr *)skb_network_header(skb);
}

и  skb_network_header объявляется в
/usr/src/linux-2.6.*/include/linux/skbuff.h:

static inline unsigned char *skb_network_header(const struct sk_buff *skb)
{
	return skb->network_header;
}

Что в основном делается выше - это передается IP заголовок текущего пакета функции
raw_v4_input как отдельная iphdr структура. Это делается путем приведения данных skbuff
где skb->network_header указывает (начало IP заголовка) на структуру iphdr.

Пришло время для анализа raw_v4_input:

/usr/src/linux-2.6.*/net/ipv4/raw.c:

/* IP input processing comes here for RAW socket delivery.
 * Caller owns SKB, so we must make clones.
 *
 * RFC 1122: SHOULD pass TOS value up to the transport layer.
 * -> It does. And not only TOS, but all IP header.
 */
int raw_v4_input(struct sk_buff *skb, struct iphdr *iph, int hash)
{
	struct sock *sk;
	struct hlist_head *head;
	int delivered = 0;

	read_lock(&raw_v4_lock);
	head = &raw_v4_htable[hash];
	if (hlist_empty(head))
		goto out;
	sk = __raw_v4_lookup(__sk_head(head), iph->protocol,
			     iph->saddr, iph->daddr,
			     skb->dev->ifindex);

	while (sk) {
		delivered = 1;
		if (iph->protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) {
		struct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);

			/* Not releasing hash table! */
			if (clone)
				raw_rcv(sk, clone);
		}
		sk = __raw_v4_lookup(sk_next(sk), iph->protocol,
				     iph->saddr, iph->daddr,
				     skb->dev->ifindex);
	}
out:
	read_unlock(&raw_v4_lock);
	return delivered;
}

Обратите внимание на то, что функция __raw_v4_lookup() которая по существу проверяет был
ли приложением создан сырой сокет с номером протокола указанным в заголовке IP, учитывает
iph->protocol как и ожидается. Одна из наиболее важных частей приведенного выше кода это
функция skb_clone() которая вызывается столько раз, сколько приложений нуждается в копии
датаграммы. Это реализовано внутри цикла while.  Следующая часть это вызов raw_rcv():
 
int raw_rcv(struct sock *sk, struct sk_buff *skb)
{
	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) {
		kfree_skb(skb);
		return NET_RX_DROP;
	}
	nf_reset(skb);

	skb_push(skb, skb->data - skb_network_header(skb));

	raw_rcv_skb(sk, skb);
	return 0;
}

Эта функция выполняет две вещи: ( крайне важно, чтобы то что находится ниже понималось,
поскольку эта часть решает возмоные возражения против нашей мысли о передаче всей  IP
датаграммы в сырой сокет)

1) Вызовается skb_push(), чтобы вернуть skbuff в его старую форму.
skb_push() это точная противоположность skb_pull():

/**
 *	skb_push - add data to the start of a buffer
 *	@skb: buffer to use
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the buffer at the buffer
 *	start. If this would exceed the total buffer headroom the kernel will
 *	panic. A pointer to the first byte of the extra data is returned.
 */
static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
{
	skb->data -= len;
	skb->len  += len;
	if (unlikely(skb->data<skb->head))
		skb_under_panic(skb, len, current_text_addr());
	return skb->data;
}

Итак, сейчас вспомните его аргументы и на что skbuff был похож на диаграмме выше.

	skb_push(skb, skb->data - skb_network_header(skb));

Сейчас skbuff будет выглядеть вот так:

sk_buff {			    buffer
				-------------- 	
.skb_data                       |	     |
	|                       --------------
        |------------------>    | IP header  | <----
                                --------------     |
                           ->	| IP payload |     |
	                   |    |	     |     |
.transport_header ---------|    |	     |     |
	                        --------------	   |	
.network_header ------------------------------------

}

Вы можете сейчас удивиться, почему часть skb_pull() сверху , если мы собирались повернуть
назад в любом случае вызывая skb_push() чтобы сделать точно противоложную операцию? Ответ
на этот вопрос, это то, что сырые сокеты это промежуточное место , где проходят
датаграммы. В обычном случае, когда не сырые сокеты открыты для какого-то
IPPROTO_protocol, тогда как пакет передается на верх по сетевому стеку skb_pull() является
естественным, поскольку пакет медленно избавляется от заголовком нижнего уровня. Однако,
эти накладные расходы можно избежать возможным вызовом skb_pull(), после того как механизм
сырых сокетов подается и таким образом избегая дополнительного skb_push() внутри raw_rcv().
(Хотя это должно быть проверено).

2) Вызывается raw_rcv_skb() которая  отвечает за вызов универсальной функции которая передает
sk_buff сокету приложения  ( и также увеличивает счетчик необработанных raw, в случае если
это не удается ):

static int raw_rcv_skb(struct sock * sk, struct sk_buff * skb)
{
	/* Charge it to the socket. */

	if (sock_queue_rcv_skb(sk, skb) < 0) {
		/* FIXME: increment a raw drops counter here */
		kfree_skb(skb);
		return NET_RX_DROP;
	}

	return NET_RX_SUCCESS;
}

Из всего, что представленно выше, мы заключаем, что не только данные IP  передаются в
сырой сокет, но также и IP заголовок.


b. FreeBSD
**********

FreeBSD использует другой подход. Сырым сокетам никода не передается TCP или UDP пакет.
Такие пакеты нужно читать непосредственно с уровня datalink используя такие библиотеки как
libpcap или bpf API. Так же никогда не передается фрагментированная датаграмма. Каждая
датаграмма полностью собирается до того как она передастся сырому сокету. 
FreeBSD передает сырому сокету:
	a) IP датаграмму с указанным в поле протокол  протоколом не зарегистрированным в
	ядре
	b) все IGMP пакеты после того как ядро закончит их обработку
	с) все ICMP пакеты ( за исключением echo запросов, timestamp запросов и address
	mask запросов) после того как ядро закончит их обработку

Мы будем изучать первый пример который для нас более интересен. Но до этого, изучим  немного
вводного материала о том как ядро FreeBSD регистрирует обработчики протоколов.

В части 0x2. Создание, мы упоминали несколько вещей о структурaх protosw которые
ассоциируют тип SOCK_XXX с протоколом IPPROTO_XXX  и находятся в глобальной таблице
inetsw[]. Кроме этого, они имеют имеют members, которые указывают на соответствующие
обработчики протоколов (также называемые hooks). pr_input() отвечает за обработку данных
от протокола находящегося уровнем ниже, тогда как pr_output() обрабатывает данные
передающиеся выщестоящему протоколу.

/usr/src/sys/sys/protosw.h:

struct protosw {
	short	pr_type;		/* socket type used for */
	struct	domain *pr_domain;	/* domain protocol a member of */
	short	pr_protocol;		/* protocol number */
	short	pr_flags;		/* see below */
/* protocol-protocol hooks */
	pr_input_t *pr_input;		/* input to protocol (from below) */
	pr_output_t *pr_output;		/* output to protocol (from above) */
	pr_ctlinput_t *pr_ctlinput;	/* control input (from below) */
	pr_ctloutput_t *pr_ctloutput;	/* control output (from above) */
/* user-protocol hook */
	pr_usrreq_t	*pr_ousrreq;
/* utility hooks */
	pr_init_t *pr_init;
	pr_fasttimo_t *pr_fasttimo;	/* fast timeout (200ms) */
	pr_slowtimo_t *pr_slowtimo;	/* slow timeout (500ms) */
	pr_drain_t *pr_drain;		/* flush any excess space possible */

	struct	pr_usrreqs *pr_usrreqs;	/* supersedes pr_usrreq() */
};

Так что IP как правило будет вызывать соответствующий обработчик pr_input() когда получит
пакет, благодаря этой таблице. Для того, что бы знать какой протокол какому обработчику
передавать, необходима фаза инифиализации. Изначально, все структуры protosw
инициализируются в /usr/src/sys/netinet/in_proto.c 

Это походит на то, что мы видели ранее на Linux в
/usr/src/linux-2.6.*/net/ipv4/af_inet.c

struct protosw inetsw[] = {
{
	.pr_type =		0,
	.pr_domain =		&inetdomain,
	.pr_protocol =		IPPROTO_IP,
	.pr_init =		ip_init,
	.pr_slowtimo =		ip_slowtimo,
	.pr_drain =		ip_drain,
	.pr_usrreqs =		&nousrreqs
},
{
	.pr_type =		SOCK_DGRAM,
	.pr_domain =		&inetdomain,
	.pr_protocol =		IPPROTO_UDP,
	.pr_flags =		PR_ATOMIC|PR_ADDR,
	.pr_input =		udp_input,
	.pr_ctlinput =		udp_ctlinput,
	.pr_ctloutput =		ip_ctloutput,
	.pr_init =		udp_init,
	.pr_usrreqs =		&udp_usrreqs
},
{
	.pr_type =		SOCK_STREAM,
	.pr_domain =		&inetdomain,
	.pr_protocol =		IPPROTO_TCP,
	.pr_flags =		PR_CONNREQUIRED|PR_IMPLOPCL|PR_WANTRCVD,
	.pr_input =		tcp_input,
	.pr_ctlinput =		tcp_ctlinput,
	.pr_ctloutput =		tcp_ctloutput,
	.pr_init =		tcp_init,
	.pr_slowtimo =		tcp_slowtimo,
	.pr_drain =		tcp_drain,
	.pr_usrreqs =		&tcp_usrreqs
},
/* #ifdef SCTP */
/* ... */
/* #endif */
{
	.pr_type =		SOCK_RAW,
	.pr_domain =		&inetdomain,
	.pr_protocol =		IPPROTO_RAW,
	.pr_flags =		PR_ATOMIC|PR_ADDR,
	.pr_input =		rip_input,
	.pr_ctlinput =		rip_ctlinput,
	.pr_ctloutput =		rip_ctloutput,
	.pr_usrreqs =		&rip_usrreqs
},
{
	.pr_type =		SOCK_RAW,
	.pr_domain =		&inetdomain,
	.pr_protocol =		IPPROTO_ICMP,
	.pr_flags =		PR_ATOMIC|PR_ADDR|PR_LASTHDR,
	.pr_input =		icmp_input,
	.pr_ctloutput =		rip_ctloutput,
	.pr_usrreqs =		&rip_usrreqs
},
{
	.pr_type =		SOCK_RAW,
	.pr_domain =		&inetdomain,
	.pr_protocol =		IPPROTO_IGMP,
	.pr_flags =		PR_ATOMIC|PR_ADDR|PR_LASTHDR,
	.pr_input =		igmp_input,
	.pr_ctloutput =		rip_ctloutput,
	.pr_init =		igmp_init,
	.pr_fasttimo =		igmp_fasttimo,
	.pr_slowtimo =		igmp_slowtimo,
	.pr_usrreqs =		&rip_usrreqs
},
{
	.pr_type =		SOCK_RAW,
	.pr_domain =		&inetdomain,
	.pr_protocol =		IPPROTO_RSVP,
	.pr_flags =		PR_ATOMIC|PR_ADDR|PR_LASTHDR,
	.pr_input =		rsvp_input,
	.pr_ctloutput =		rip_ctloutput,
	.pr_usrreqs =		&rip_usrreqs
},

Вопрос в том как IP понимает какой обработчик протокола должен тоже получить пакет? Это
дeлaeтся исследуя поле Protocol в заголовке IP (мы говороли об этом выше) и затем  смотря
таблицу ip_protox[] которая инициализируется в функции ip_init().

/usr/src/sys/netinet/ip_input.c:

void
ip_init(void)
{
	struct protosw *pr;
	int i;

	TAILQ_INIT(&in_ifaddrhead);
	in_ifaddrhashtbl = hashinit(INADDR_NHASH, M_IFADDR, &in_ifaddrhmask);
	pr = pffindproto(PF_INET, IPPROTO_RAW, SOCK_RAW);
	if (pr == NULL)
		panic("ip_init: PF_INET not found");

	/* Initialize the entire ip_protox[] array to IPPROTO_RAW. */
	for (i = 0; i < IPPROTO_MAX; i++)
		ip_protox[i] = pr - inetsw;
	/*
	 * Cycle through IP protocols and put them into the appropriate place
	 * in ip_protox[].
	 */
	for (pr = inetdomain.dom_protosw;
	    pr < inetdomain.dom_protoswNPROTOSW; pr++)
		if (pr->pr_domain->dom_family == PF_INET &&
		    pr->pr_protocol && pr->pr_protocol != IPPROTO_RAW) {
			/* Be careful to only index valid IP protocols. */
			if (pr->pr_protocol < IPPROTO_MAX)
				ip_protox[pr->pr_protocol] = pr - inetsw;
		}
/* ... */

}

Массив ip_protox[] это не что иное как простой ассоциативный массив который используется
IP для демультиплексирования входящих датаграмм основываясь на *реальном* номере протокола
транспортного уровня. Что мы действительно имеем ввиду? Действительный номер находящийся в
заголовке IP в поле Protocol - стандартизированный всеми RFC номер. Номер определенный в 
/usr/src/linux-2.6.*/include/linux/in.h в Linux и в /usr/src/sys/netinet/in.h.
IPPROTO_XXX. Большинство протоколов имеют такой определенный глобально номер.


Таблица inetsw[] не имеет структур протоколов protosw урегулированных по этому номеру.
Например TCP который определен быть номером протокола 6 в inetsw[2].  Поэтому ip_protox[6]
указывает на inetsw[2]. Довольно просто. Такая же логика работает для всех протоколов
которым IP может понадобиться также передать датаграммы.
Еще одна диаграмма:

	ip_protox[]					inetsw[]

	---------					---------
0       |   3	|                               	|  IP	|
        ---------                               	---------
1       |   4	|-------------------------|           	|  UDP	|
        ---------                         |      	---------
2	|   5	|------|         |-------------------> 	|  TCP	|
        ---------      |         |        |      	---------
3	|   	|      |         |        |      	|IP(raw)| (default)
	---------      |         |        |      	---------
4	|	|      |         |        |---------> 	| ICMP	|
        ---------      |         |                	---------
5	|	|      |-----------------------------> 	| IGMP	| 
        ---------		 |                      ---------
6	|   3	|----------------|               	|  ...  | 
	---------                                       ---------
7	|	|					|  ...  |
	---------					---------
...	|  ...  |					|IP(raw)| (wildcard)
	---------					---------

( не представленные выше, во избежание захламления, это указатели приходящие из
незарегистрированных протоколов и подходящие на значение поумолчанию - IP(raw).

Где в этой части  SOCK_RAW и IPPROTO_RAW вступают в игру?  Проще говоря, если  их protosw
не существует,  ядро паникует! Почему так? Потому что каждая запись в ip_protox[] должна
быть инициализирована, что-бы указывать на (первую) IP(raw) структуру protosw. И на это
есть уважительная причина: если ядро не знает как обрабатывать протокол (другого
зарегистрированного обработчика для него нет) оно передает его обработчику по умолчанию -
SOCK_RAW - IPPROTO_RAW (default_RAW).
Так важно его существование во всех современных ядрах. Конечно, все записи ip_protox[]
которые имеют обработчик для определенного номера протокола , определены указывать
на фактически на запись в inetsw[], следовательно переопределяя указатель на значение по
умолчанию.  Но все те что  не имеют ( не официально ), существуют на IP(raw).

Зная это, ip_input после того как выполнит все проверки, ( к примеру, посмотрит, что
чексумма датаграммы правильная) в конце концов может вызвать обработчик верхнего уровня.
замечание: верхне-уровневый протокол не обязательно должен быть - transport level,
поскольку IP может нести датаграммы ICMP, IGMP которые *не* транспортные протоколы, но
считаются частью network layer.


/usr/src/sys/netinet/ip_input.c:

/*
 * Ip input routine.  Checksum and byte swap header.  If fragmented
 * try to reassemble.  Process options.  Pass to next level.
 */
void
ip_input(struct mbuf *m)
{
	struct ip *ip = NULL;
	struct in_ifaddr *ia = NULL;
	struct ifaddr *ifa;
	int    checkif, hlen = 0;
	u_short sum;
	int dchg = 0;				/* dest changed after fw */
	struct in_addr odst;			/* original dst address */

	/* ... */

	/*
	 * Switch out to protocol's input routine.
	 */
	ipstat.ips_delivered++;

	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen);
	return;
bad:
	m_freem(m);
}

Сейчас допустим, что что ip->ip_p ( поле Protocol в ip заголовке ) это , что-то , что *не
имеет*  зарегистрированного обработчика в ядре. 
Что будет вызывать слудующая строчка из ip_input()?

	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen);

Вы правильно предполагаете. pr_input of inetsw[default_RAW] (SOCK_RAW - IPPROTO_RAW).
Пришло время разобраться с rip_input().


/usr/src/sys/netinet/raw_ip.c:

/*
 * Setup generic address and protocol structures
 * for raw_input routine, then pass them along with
 * mbuf chain.
 */
void
rip_input(struct mbuf *m, int off)
{
	struct ip *ip = mtod(m, struct ip *);
	int proto = ip->ip_p;
	struct inpcb *inp, *last;

	INP_INFO_RLOCK(&ripcbinfo);
	ripsrc.sin_addr = ip->ip_src;
	last = NULL;
	LIST_FOREACH(inp, &ripcb, inp_list) {
		INP_LOCK(inp);
		if (inp->inp_ip_p && inp->inp_ip_p != proto) {
	docontinue:
			INP_UNLOCK(inp);
			continue;
		}
#ifdef INET6
		if ((inp->inp_vflag & INP_IPV4) == 0)
			goto docontinue;
#endif
		if (inp->inp_laddr.s_addr &&
		    inp->inp_laddr.s_addr != ip->ip_dst.s_addr)
			goto docontinue;
		if (inp->inp_faddr.s_addr &&
		    inp->inp_faddr.s_addr != ip->ip_src.s_addr)
			goto docontinue;
		if (jailed(inp->inp_socket->so_cred))
			if (htonl(prison_getip(inp->inp_socket->so_cred)) !=
			    ip->ip_dst.s_addr)
				goto docontinue;
		if (last) {
			struct mbuf *n;

			n = m_copy(m, 0, (int)M_COPYALL);
			if (n != NULL)
				(void) raw_append(last, ip, n);
			/* XXX count dropped packet */
			INP_UNLOCK(last);
		}
		last = inp;
	}
	if (last != NULL) {
		if (raw_append(last, ip, m) != 0)
			ipstat.ips_delivered--;
		INP_UNLOCK(last);
	} else {
		m_freem(m);
		ipstat.ips_noproto++;
		ipstat.ips_delivered--;
	}
	INP_INFO_RUNLOCK(&ripcbinfo);
}

Читая представленный выше код, мы можем различить следующие пункты:

1) Если сырой сокет (type SOCK_RAW) был создан со значением protocol = 0, тогда:

	а) если процесс вызвал bind() и обозначенный адрес совпадает с адресом назначения
	в датаграмме тогда *ВСЕ* такие датаграммы, которые ядро не знает как обрабатывать
	передаются этому сырому сокету
	
	b) если процес вызвал connect() и обозначенный адрес не совпадает с адресом
	назначения в датаграмме, тогда *ВСЕ* такие датаграммы которые ядро не знает как
	обрабатывать , передаются сырому сокету.

	с) если процесс не вызвал bind() и socket(), тогда *ВСЕ* датаграммы которые ядро
	не знает как обрабатывать передаются этому сырому сокету.

	d) любая комбинация от a до b которая не прошла, значит что датаграмма не
	предается приложению.

2) Если сырой сокет ( type SOCK_RAW ) создан со значением protocol не равным 0, тогда мы
имеем следующие варианты:

	a) если значение protocol имеет зарегистрированный обработчик в ядре, приложение
	*НЕ ПОЛУЧАЕТ* никаких датаграмм ( за исключением ICMP, IGMP которые работают по
	другому механизму, не обсуждаемому здесь).
	
	b) если значение protocol не имеет зарегистрированного обработчика в ядре,
	приложение получает *только* дататаграммы которые имеют это значение protocol в 
	заголовке IP.

Вышесказанное может быть выведено из следующего обрезка кода:

		if (inp->inp_ip_p && inp->inp_ip_p != proto) {
	docontinue:
			INP_UNLOCK(inp);
			continue;
		}
		if (inp->inp_laddr.s_addr &&
		    inp->inp_laddr.s_addr != ip->ip_dst.s_addr)
			goto docontinue;
		if (inp->inp_faddr.s_addr &&
		    inp->inp_faddr.s_addr != ip->ip_src.s_addr)
			goto docontinue;


Используя логику от обратного, проверка INP_UNLOCK  игнорирует любую датаграмму которая
имеет не нулевое значение поля protocol и сырой сокет который проверяетcя не имеет этого
протокола. Это значит, что любой сырой сокет, который определяет значение protocol в 0
пройдет эту проверку и не будет игнорирован. Тоже самое подходит для любого сырого сокета
котрый имеет не нулевое значение protocol, но имеет такое же значение protocol как и
проверяемая датаграмма.
Тоже применимо к двум проверкам которые слудуют после первой, которые проверяют локальный
и удаленный адреса ( в случае если были вызваны bind() и/или  connect() ).
Конечно, случай где  приложение не получает никакой датаграммы хотя и создало сырой
сокет (но с зарегистрированным протоколом) выходит из факта, что rip_input() в этом
варианте не будет вызван совсем.

Небольая скобка, чтобы прокоментировать кое-что из man *BSD.
Man 4 ip конкретно коворит так:
"Если proto равно 0, по умолчанию для исоходящих пакетов используется протокол
IPPROTO_RAW, и только входящие для этого протокола принимаются."

Это окончательно сбивает с толку, поскольку это звучит как, создание сырого сокета со
значением protocol 0  в результате дает, что только пакеты предназначенные для
IPPROTO_RAW(255) принимаются и никакие больше. Однако это не правда, и автор страниц
мануала, хочет сказать, что каждая IP датаграмма, которая имеет зачение protocol *в
результате IP демультиплексирования ip_protox[] указывает на значение IPPROTO_RAW* (
помните, что все незнакомые протоколы указывают на значение по умолчанию) тогда сокет
получит эти датаграммы. По этому определению, это верно.

Самое смешное, что указание протокола IPPROTO_RAW при  создании сырого сокета, *обычно*
будет то , что сокет не получит *любую* датаграмму основываясь на логике выше. Обычно,
потому, что датаграммы с таким номером протокола не появляются/должны появляться на
проводе.

Конечно же это не значит, что процесс не может подделать пакет с таким номером протокола и
отправить его. Это другой случай основной разницы между не должен и не может. В дополнение
к этому не все подделывающие покеты программы хотят общаться... ( в двух направлениях ).
На Linux тоже самое произошло бы , поскольку raw_v4_input() вызывается каждый раз и будет
проверяться если сырой сокет  с номером protocol IPPROTO_RAW существует в user space.

Следующие две небольшие программы демонстрируют функционал IPPROTO_RAW в Linux. Помните из
части 0x3. IP_HDRINCL что ядро Linux  устанавливает IP_HDRINCL по умолчанию, когда создает
сокет с IPPROTO_RAW, чтож мы создадим свой собственный заголовок  , чтобы не отправлять
мусор на провод. Мы будем использовать loopback интерфейс, но тот же самый эффект будет с
любым настоящим ethernet устройством.
Обе программы так же работают на FreeBSD/OpenBSD, хотя создание собственного IP заголовка
не необходимость ( в таком случае netinet/in.h должен использоваться вместо netinet/ip.h)


/*** IPPROTO_RAW receiver ***/
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>


int main(void)
{
	int s;
	struct sockaddr_in saddr;
	char packet[50];

	if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
		perror("error:");
		exit(EXIT_FAILURE);
	}

	memset(packet, 0, sizeof(packet));
	socklen_t *len = (socklen_t *)sizeof(saddr);
	int fromlen = sizeof(saddr);

	while(1) {
		if (recvfrom(s, (char *)&packet, sizeof(packet), 0,
			(struct sockaddr *)&saddr, &fromlen) < 0)
			perror("packet receive error:");

		int i = sizeof(struct iphdr);	/* print the payload */
		while (i < sizeof(packet)) {
			fprintf(stderr, "%c", packet[i]);
			i++;
		}
		printf("\n");
	}
	exit(EXIT_SUCCESS);
}


/*** IPPROTO_RAW sender ***/
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define DEST "127.0.0.1"

int main(void)
{

	int s;
	struct sockaddr_in daddr;
	char packet[50];
	/* point the iphdr to the beginning of the packet */
	struct iphdr *ip = (struct iphdr *)packet;  

	if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
		perror("error:");
		exit(EXIT_FAILURE);
	}

	daddr.sin_family = AF_INET;
	daddr.sin_port = 0; /* not needed in SOCK_RAW */
	inet_pton(AF_INET, DEST, (struct in_addr *)&daddr.sin_addr.s_addr);
	memset(daddr.sin_zero, 0, sizeof(daddr.sin_zero));
	memset(packet, 'A', sizeof(packet));   /* payload will be all As */
	
	ip->ihl = 5;
	ip->version = 4;
	ip->tos = 0;
	ip->tot_len = htons(40);	/* 16 byte value */
	ip->frag_off = 0;		/* no fragment */
	ip->ttl = 64;			/* default value */
	ip->protocol = IPPROTO_RAW;	/* protocol at L4 */
	ip->check = 0;			/* not needed in iphdr */
	ip->saddr = daddr.sin_addr.s_addr;
	ip->daddr = daddr.sin_addr.s_addr;

	while(1) {
		sleep(1);
		if (sendto(s, (char *)packet, sizeof(packet), 0, 
			(struct sockaddr *)&daddr, (socklen_t)sizeof(daddr)) < 0)
			perror("packet send error:");
	}
	exit(EXIT_SUCCESS);
}

Их запуск в результате даст прекрасное взаимодействие между ними, поскольку ничто их не
останавливает от использования IPPROTO_RAW(255) как L4 протокол.

#./send

#tcpdump -i lo -X -vv

19:49:27.048431 IP (tos 0x0, ttl 64, id 16705, offset 0, flags [none], 
proto unknown (255), length 50) localhost.localdomain > localhost.localdomain:
ip-proto-255 30
        0x0000:  4500 0032 4141 0000 40ff 3a8a 7f00 0001  E..2AA..@.:.....
        0x0010:  7f00 0001 4141 4141 4141 4141 4141 4141  ....AAAAAAAAAAAA
        0x0020:  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
        0x0030:  4141                                     AA
19:49:28.048466 IP (tos 0x0, ttl 64, id 16705, offset 0, flags [none], 
proto unknown (255), length 50) localhost.localdomain > localhost.localdomain:
ip-proto-255 30
        0x0000:  4500 0032 4141 0000 40ff 3a8a 7f00 0001  E..2AA..@.:.....
        0x0010:  7f00 0001 4141 4141 4141 4141 4141 4141  ....AAAAAAAAAAAA
        0x0020:  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
        0x0030:  4141  

#./recv
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Далее rip_input() аналитика:

Как Linux использует skb_clone для создания копии датаграммы, FreeBSD использует m_copy (
mbuf вместо sk_buff структуры ).  Кончено, копия делается только когда это считается
необходимым - т.е есть соответствующий сырой сокет (который не игнорируется по одной из
упомянутых выше причин) который найден за время цикла поиска. m_copy это довольно дорогая
операция , поскольку она включает в себя копирование настоящей памяти, а не просто
передвигаение указателя. По этой причине, FreeBSD  использует более разумный подход для
избежания выполнения этой операции когда только одно приложение нуждается в датаграмме.
Это выполняется с использованием последней переменной которая указывает на последний
найденный сокет котрому нужны датаграмма. Для полноты картины , давайте обсудим логику
происходящего:

последние первые указывают на NULL. Если сокет признается способным, что бы иметь текущую
датаграмму, что значит он прошел все проверки, скажем на итерации i, тогда последний будет
указывать на него ,но условие if не будет выполнено (первый раз). На итерации i+N,где N
это сокет после сокета i,который был так же считается способным принят датаграмму,
выполнится m_copy() поскольку условие if не будет верно. Затем будет вызван raw_append(),
который будет отвечать за передачу датагрммы приложению вызовом sbappendaddr_locked() 
(смотри  raw_append()). Этот механизм будет продолжать работать до тех пор, пока весь
список сырых сокетов не пройдуться. Условие if которое снаружи LIST_FOREACH цикла, нужно
для передачи копии датаграммы последнему сырому сокету, которому это необходимо. Если нет
сокетов которым это нужно, тогда копия не делается.

	last = NULL;
	LIST_FOREACH(inp, &ripcb, inp_list) {

	/* which-sockets-to-ignore logic */
	/* ... */

		if (last) {
			struct mbuf *n;

			n = m_copy(m, 0, (int)M_COPYALL);
			if (n != NULL)
				(void) raw_append(last, ip, n);
			/* XXX count dropped packet */
			INP_UNLOCK(last);
		}
		last = inp;
	}
	
	if (last != NULL) {
		if (raw_append(last, ip, m) != 0)
			ipstat.ips_delivered--;
		INP_UNLOCK(last);
	} else {
		m_freem(m);
		ipstat.ips_noproto++;
		ipstat.ips_delivered--;
	}
	INP_INFO_RUNLOCK(&ripcbinfo);


Заметим, что Linux всегда далает как минимум одну копию, даже если один сырой сокет
нуждается в датаграмме. Это происходит потому, что как мы и сказали об этом выше, Linux
использует механизм сырых сокетов как man-in-the-middle,  означающее что датаграмма может
передана обычному приложению совместо с приложением использующим raw-sockets.
FreeBSD передает всю IP датаграмму (совместно с IP заголовком) приложению, так же как и
Linux.



0x5. raw output
===============

Зная как обрабатывается raw датаграммы, мы готовы рассмотреть в деталях raw output
механизм. Что мы будем изучать здесь, это какое значение IP заголовка пишется по умолчанию
каждым ядром и за заполнение каких ответственны мы. И конечно это применимо только когда
включена опция IPHDRINCL ( либо включена нами, либо ядром по умолчанию [Linux - IPPROTO_RAW]).



a. Linux
********
